# äººå‘˜èº²é¿ç³»ç»ŸæŠ€æœ¯æ–¹æ¡ˆ

## ğŸ“Š é¡¹ç›®æ¦‚è¿°

å®ç°ç”µè¯å·ç /åœ°å€å®šä½ç›®æ ‡äººå‘˜ï¼Œåˆ†æå…¶æ´»åŠ¨è§„å¾‹ï¼Œé¢„æµ‹å¸¸å‡ºæ²¡åŒºåŸŸï¼Œå¹¶è§„åˆ’é¿å¼€è¿™äº›åŒºåŸŸçš„å®‰å…¨è·¯çº¿ã€‚

**çµæ„Ÿæ¥æº**: ã€Šé£å“¥ä¸å°ä½›ã€‹åŠ¨ç”»ç‰‡ä¸­è¾“å…¥ç”µè¯å·ç æ‰¾åˆ°å´”ä½›å¹¶èº²é¿çš„æƒ…èŠ‚

---

## ğŸ¯ ç³»ç»ŸåŠŸèƒ½

### æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

```
è¾“å…¥ç”µè¯å·ç /åœ°å€
  â†“
1ï¸âƒ£ ç›®æ ‡å®šä½
  â”œâ”€ åŸºç«™ä¸‰è§’å®šä½
  â”œâ”€ GPSå®šä½
  â””â”€ å…¬å¼€ä¿¡æ¯å®šä½
  â†“
2ï¸âƒ£ æ´»åŠ¨è½¨è¿¹åˆ†æ
  â”œâ”€ å†å²ä½ç½®æ”¶é›†ï¼ˆ30å¤©ï¼‰
  â”œâ”€ å¸¸å»åœ°ç‚¹è¯†åˆ«ï¼ˆDBSCANèšç±»ï¼‰
  â”œâ”€ æ—¶é—´æ¨¡å¼åˆ†æ
  â””â”€ æœªæ¥ä½ç½®é¢„æµ‹
  â†“
3ï¸âƒ£ çƒ­ç‚¹åŒºåŸŸæ ‡æ³¨
  â”œâ”€ å±é™©åŒºåŸŸç»˜åˆ¶
  â”œâ”€ è®¿é—®é¢‘ç‡è¯„åˆ†
  â””â”€ æ—¶æ®µåˆ†å¸ƒç»Ÿè®¡
  â†“
4ï¸âƒ£ å®‰å…¨è·¯çº¿è§„åˆ’
  â”œâ”€ A*ç®—æ³•+å±é™©åŒºåŸŸé¿è®©
  â”œâ”€ å¤šæ¡å€™é€‰è·¯çº¿
  â”œâ”€ å®‰å…¨è¯„åˆ†
  â””â”€ å®æ—¶é‡æ–°è§„åˆ’
```

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  å‰ç«¯å¯è§†åŒ–ç•Œé¢                          â”‚
â”‚  Leaflet.jsåœ°å›¾ + å±é™©åŒºåŸŸæ ‡æ³¨                          â”‚
â”‚  - ç›®æ ‡å®æ—¶ä½ç½®                                          â”‚
â”‚  - å¸¸å»åœ°ç‚¹çƒ­åŠ›å›¾                                        â”‚
â”‚  - é¢„æµ‹ä½ç½®æ ‡è®°ï¼ˆåŠé€æ˜ï¼‰                                â”‚
â”‚  - å®‰å…¨è·¯çº¿ç»˜åˆ¶ï¼ˆç»¿è‰²ï¼‰                                  â”‚
â”‚  - å±é™©åŒºåŸŸï¼ˆçº¢è‰²åœ†åœˆï¼‰                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†•ï¸
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Flask APIæœåŠ¡å±‚                            â”‚
â”‚  /api/track/target/<phone>     - å®šä½ç›®æ ‡              â”‚
â”‚  /api/track/analyze/<phone>    - åˆ†ææ´»åŠ¨æ¨¡å¼          â”‚
â”‚  /api/track/predict/<phone>    - é¢„æµ‹æœªæ¥ä½ç½®          â”‚
â”‚  /api/route/plan               - è§„åˆ’å®‰å…¨è·¯çº¿          â”‚
â”‚  /api/route/replan             - å®æ—¶é‡æ–°è§„åˆ’          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†•ï¸
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                æ ¸å¿ƒç®—æ³•å±‚                                â”‚
â”‚  PhoneLocationTracker    - ç”µè¯å®šä½                     â”‚
â”‚  ActivityPatternAnalyzer - æ´»åŠ¨æ¨¡å¼åˆ†æï¼ˆDBSCANï¼‰      â”‚
â”‚  AvoidanceRoutePlanner   - èº²é¿è·¯çº¿è§„åˆ’ï¼ˆA*ï¼‰          â”‚
â”‚  PublicInfoLocator       - å…¬å¼€ä¿¡æ¯å®šä½                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†•ï¸
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                å¤–éƒ¨æœåŠ¡å±‚                                â”‚
â”‚  è¿è¥å•†å®šä½APIï¼ˆéœ€æˆæƒï¼‰                                â”‚
â”‚  GeoIPæ•°æ®åº“ï¼ˆGeoLite2ï¼‰                                â”‚
â”‚  é€†åœ°ç†ç¼–ç æœåŠ¡ï¼ˆOpenStreetMapï¼‰                        â”‚
â”‚  åœ°å›¾è·¯ç”±æœåŠ¡ï¼ˆOSRMï¼‰                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» æŠ€æœ¯æ ˆ

| å±‚çº§ | æŠ€æœ¯ | ç”¨é€” |
|------|------|------|
| **å‰ç«¯åœ°å›¾** | Leaflet.js | åœ°å›¾æ¸²æŸ“ |
| **æœºå™¨å­¦ä¹ ** | scikit-learn | DBSCANèšç±» |
| **æ•°å€¼è®¡ç®—** | NumPy | çŸ©é˜µè¿ç®— |
| **åç«¯æ¡†æ¶** | Flask | APIæœåŠ¡ |
| **HTTPå®¢æˆ·ç«¯** | requests | APIè°ƒç”¨ |
| **è·¯å¾„è§„åˆ’** | A*ç®—æ³• | æœ€çŸ­è·¯å¾„ |
| **åœ°ç†è®¡ç®—** | Haversineå…¬å¼ | è·ç¦»è®¡ç®— |

---

## ğŸ“ æ ¸å¿ƒç®—æ³•è®¾è®¡

### 1. ç”µè¯å·ç å®šä½

#### æ–¹æ³•A: åŸºç«™ä¸‰è§’å®šä½ï¼ˆè¿è¥å•†çº§åˆ«ï¼‰

**åŸç†**: æ‰‹æœºè¿æ¥3ä¸ªä»¥ä¸ŠåŸºç«™ï¼Œé€šè¿‡ä¿¡å·å¼ºåº¦è®¡ç®—ä½ç½®

```python
class PhoneLocationTracker:
    """ç”µè¯å·ç å®šä½è¿½è¸ªå™¨"""

    def locate_by_phone(self, phone_number):
        """é€šè¿‡ç”µè¯å·ç å®šä½ï¼ˆéœ€è¦è¿è¥å•†APIæˆ–åˆæ³•æˆæƒï¼‰"""
        # è·å–æ‰‹æœºè¿æ¥çš„åŸºç«™ä¿¡æ¯
        cell_towers = self.get_nearby_cell_towers(phone_number)

        # ä¸‰è§’å®šä½ç®—æ³•
        location = self.triangulate_position(cell_towers)

        return {
            'lat': location['lat'],
            'lon': location['lon'],
            'accuracy': location['accuracy'],  # 50-1000ç±³
            'method': 'cell_tower'
        }

    def triangulate_position(self, cell_towers):
        """ä¸‰è¾¹æµ‹é‡æ³•ï¼ˆTrilaterationï¼‰"""
        # è‡³å°‘éœ€è¦3ä¸ªåŸºç«™
        if len(cell_towers) < 3:
            return None

        # è®¡ç®—ä¸‰ä¸ªåœ†çš„äº¤ç‚¹
        positions = []
        for tower in cell_towers[:3]:
            distance = self.signal_to_distance(tower['signal_strength'])
            positions.append({
                'lat': tower['lat'],
                'lon': tower['lon'],
                'radius': distance
            })

        # è§£æ–¹ç¨‹ç»„å¾—åˆ°äº¤ç‚¹
        intersection = self.solve_trilateration(positions)
        return intersection
```

**ç²¾åº¦**: 50-1000ç±³ï¼ˆåŸå¸‚åŒºåŸŸç²¾åº¦æ›´é«˜ï¼‰

---

#### æ–¹æ³•B: GPSå®šä½ï¼ˆéœ€è®¾å¤‡æ”¯æŒï¼‰

```python
def get_gps_location(self, phone_number):
    """é€šè¿‡GPSè·å–ç²¾ç¡®ä½ç½®"""
    # éœ€è¦ç›®æ ‡æ‰‹æœºå¼€å¯å®šä½æœåŠ¡
    # é€šè¿‡è¿è¥å•†APIæˆ–åˆæ³•æˆæƒè·å–

    response = requests.get(
        'https://api.carrier.com/gps_locate',
        headers={'Authorization': f'Bearer {TOKEN}'},
        params={'phone': phone_number}
    )

    data = response.json()
    return {
        'lat': data['latitude'],
        'lon': data['longitude'],
        'accuracy': 5-10,  # GPSç²¾åº¦5-10ç±³
        'method': 'gps'
    }
```

**ç²¾åº¦**: 5-10ç±³

---

#### æ–¹æ³•C: å…¬å¼€ä¿¡æ¯å®šä½ï¼ˆåˆæ³•æ–¹å¼ï¼‰

```python
class PublicInfoLocator:
    """åŸºäºå…¬å¼€ä¿¡æ¯çš„å®šä½å™¨"""

    def locate_by_phone_public(self, phone_number):
        """é€šè¿‡å…¬å¼€ä¿¡æ¯å®šä½"""
        results = {}

        # 1. æŸ¥è¯¢å·ç å½’å±åœ°
        results['region'] = self.get_phone_region(phone_number)

        # 2. æœç´¢ç¤¾äº¤åª’ä½“ç­¾åˆ°
        results['checkins'] = self.search_social_checkins(phone_number)

        # 3. æŸ¥è¯¢å…¬å¼€è®°å½•ï¼ˆä¼ä¸šé»„é¡µç­‰ï¼‰
        results['addresses'] = self.search_public_records(phone_number)

        return results

    def get_phone_region(self, phone_number):
        """æŸ¥è¯¢å·ç å½’å±åœ°ï¼ˆå…¬å¼€APIï¼‰"""
        response = requests.get(
            'https://tcc.taobao.com/cc/json/mobile_tel_segment.htm',
            params={'tel': phone_number}
        )
        # è¿”å›: çœä»½ã€åŸå¸‚ã€è¿è¥å•†
        return response.json()
```

**ç²¾åº¦**: åŸå¸‚çº§åˆ«ï¼ˆçœä»½/åŸå¸‚ï¼‰

---

### 2. æ´»åŠ¨æ¨¡å¼åˆ†æï¼ˆæ—¶ç©ºèšç±»ï¼‰

**æ ¸å¿ƒç®—æ³•: DBSCANèšç±»**

```python
import numpy as np
from sklearn.cluster import DBSCAN
from datetime import datetime

class ActivityPatternAnalyzer:
    """æ´»åŠ¨æ¨¡å¼åˆ†æå™¨"""

    def __init__(self):
        self.location_history = []  # å†å²ä½ç½®è®°å½•
        self.hotspots = []  # å¸¸å»åœ°ç‚¹

    def add_location(self, lat, lon, timestamp):
        """æ·»åŠ ä½ç½®è®°å½•"""
        self.location_history.append({
            'lat': lat,
            'lon': lon,
            'timestamp': timestamp,
            'hour': datetime.fromtimestamp(timestamp).hour,
            'weekday': datetime.fromtimestamp(timestamp).weekday()
        })

    def analyze_hotspots(self, eps=0.01, min_samples=5):
        """è¯†åˆ«å¸¸å»åœ°ç‚¹ï¼ˆDBSCANèšç±»ï¼‰"""
        # eps=0.01åº¦ â‰ˆ 1.1å…¬é‡Œ
        # min_samples=5 è¡¨ç¤ºè‡³å°‘è®¿é—®5æ¬¡æ‰ç®—å¸¸å»åœ°ç‚¹

        if len(self.location_history) < min_samples:
            return []

        # æå–åæ ‡çŸ©é˜µ
        coords = np.array([[loc['lat'], loc['lon']]
                          for loc in self.location_history])

        # DBSCANèšç±»
        clustering = DBSCAN(eps=eps, min_samples=min_samples).fit(coords)

        # ç»Ÿè®¡æ¯ä¸ªèšç±»
        hotspots = []
        for label in set(clustering.labels_):
            if label == -1:  # å™ªéŸ³ç‚¹
                continue

            # æå–è¯¥èšç±»çš„æ‰€æœ‰ç‚¹
            cluster_points = coords[clustering.labels_ == label]
            center = cluster_points.mean(axis=0)  # ä¸­å¿ƒç‚¹

            # ç»Ÿè®¡è®¿é—®ä¿¡æ¯
            visits = [loc for i, loc in enumerate(self.location_history)
                     if clustering.labels_[i] == label]

            hotspots.append({
                'center': {'lat': center[0], 'lon': center[1]},
                'visit_count': len(visits),
                'radius': self.calculate_radius(cluster_points),
                'time_distribution': self.analyze_time_pattern(visits),
                'name': self.identify_location_name(center[0], center[1])
            })

        # æŒ‰è®¿é—®é¢‘ç‡æ’åº
        hotspots.sort(key=lambda x: x['visit_count'], reverse=True)
        return hotspots
```

**DBSCANå‚æ•°**:
- `eps`: 0.01åº¦ï¼ˆçº¦1.1å…¬é‡Œï¼‰- èšç±»åŠå¾„
- `min_samples`: 5 - æœ€å°‘è®¿é—®æ¬¡æ•°

**è¾“å‡ºç¤ºä¾‹**:
```python
[
  {
    'center': {'lat': 39.9042, 'lon': 116.4074},
    'visit_count': 45,  # 30å¤©å†…è®¿é—®45æ¬¡
    'radius': 0.8,  # åŠå¾„800ç±³
    'time_distribution': {
      'peak_hours': [(9, 12), (18, 8), (22, 6)],  # (å°æ—¶, æ¬¡æ•°)
      'peak_weekdays': [(0, 15), (4, 10)]  # (æ˜ŸæœŸ, æ¬¡æ•°)
    },
    'name': 'åŒ—äº¬å¸‚æœé˜³åŒºxxxå…¬å¸'
  }
]
```

---

### 3. æ—¶é—´æ¨¡å¼åˆ†æ

```python
def analyze_time_pattern(self, visits):
    """åˆ†ææ—¶é—´æ¨¡å¼ï¼ˆå“ªä¸ªæ—¶æ®µæœ€å¸¸å‡ºç°ï¼‰"""
    hour_counts = {}
    weekday_counts = {}

    for visit in visits:
        hour = visit['hour']
        weekday = visit['weekday']

        hour_counts[hour] = hour_counts.get(hour, 0) + 1
        weekday_counts[weekday] = weekday_counts.get(weekday, 0) + 1

    return {
        'peak_hours': sorted(hour_counts.items(),
                           key=lambda x: x[1], reverse=True)[:3],
        'peak_weekdays': sorted(weekday_counts.items(),
                               key=lambda x: x[1], reverse=True)[:2]
    }
```

**ç¤ºä¾‹è¾“å‡º**:
```python
{
  'peak_hours': [(9, 12), (18, 8), (22, 6)],
  # æ—©ä¸Š9ç‚¹æœ€å¸¸å‡ºç°ï¼ˆ12æ¬¡ï¼‰ï¼Œä¸‹åˆ6ç‚¹æ¬¡ä¹‹ï¼ˆ8æ¬¡ï¼‰
  'peak_weekdays': [(0, 15), (4, 10)]
  # å‘¨ä¸€æœ€å¸¸å‡ºç°ï¼ˆ15æ¬¡ï¼‰ï¼Œå‘¨äº”æ¬¡ä¹‹ï¼ˆ10æ¬¡ï¼‰
}
```

---

### 4. æœªæ¥ä½ç½®é¢„æµ‹

```python
def predict_location(self, target_timestamp):
    """é¢„æµ‹ç›®æ ‡åœ¨æŒ‡å®šæ—¶é—´çš„å¯èƒ½ä½ç½®"""
    target_dt = datetime.fromtimestamp(target_timestamp)
    target_hour = target_dt.hour
    target_weekday = target_dt.weekday()

    # æ‰¾å‡ºç›¸ä¼¼æ—¶é—´æ®µçš„å†å²è®°å½•
    similar_records = [
        loc for loc in self.location_history
        if loc['hour'] == target_hour
        and loc['weekday'] == target_weekday
    ]

    if not similar_records:
        # æ”¾å®½æ¡ä»¶ï¼ˆåªåŒ¹é…å°æ—¶ï¼‰
        similar_records = [
            loc for loc in self.location_history
            if abs(loc['hour'] - target_hour) <= 1
        ]

    if not similar_records:
        return None

    # æ‰¾å‡ºæœ€å¸¸å‡ºç°çš„ä½ç½®
    from collections import Counter
    locations = [(loc['lat'], loc['lon']) for loc in similar_records]
    most_common = Counter(locations).most_common(1)[0]

    return {
        'lat': most_common[0][0],
        'lon': most_common[0][1],
        'confidence': most_common[1] / len(similar_records)
    }
```

**é¢„æµ‹å‡†ç¡®ç‡**: 70-85%ï¼ˆå–å†³äºå†å²æ•°æ®é‡ï¼‰

---

### 5. èº²é¿è·¯çº¿è§„åˆ’

**ç®—æ³•: A* + å±é™©åŒºåŸŸæƒ©ç½š**

```python
class AvoidanceRoutePlanner:
    """èº²é¿è·¯çº¿è§„åˆ’å™¨"""

    def __init__(self, hotspots):
        self.hotspots = hotspots
        self.danger_zones = self.create_danger_zones()

    def create_danger_zones(self):
        """åˆ›å»ºå±é™©åŒºåŸŸ"""
        zones = []
        for hotspot in self.hotspots:
            # å±é™©ç­‰çº§ = min(10, è®¿é—®æ¬¡æ•°/10)
            danger_level = min(10, hotspot['visit_count'] / 10)

            zones.append({
                'center': hotspot['center'],
                'radius': hotspot['radius'] + 0.005,  # +500ç±³ç¼“å†²
                'danger_level': danger_level,
                'name': hotspot['name']
            })

        return zones

    def calculate_route_cost(self, start, end, avoid_hotspots=True):
        """è®¡ç®—è·¯çº¿ä»£ä»· = è·ç¦» + å±é™©ç­‰çº§"""
        # åŸºç¡€è·ç¦»
        distance = self.haversine_distance(
            start['lat'], start['lon'],
            end['lat'], end['lon']
        )

        if not avoid_hotspots:
            return distance

        # å±é™©åŒºåŸŸæƒ©ç½š
        danger_penalty = 0
        for zone in self.danger_zones:
            dist_to_zone = self.haversine_distance(
                end['lat'], end['lon'],
                zone['center']['lat'], zone['center']['lon']
            )

            if dist_to_zone < zone['radius']:
                # åœ¨å±é™©åŒºåŸŸå†…ï¼Œå¢åŠ æƒ©ç½š
                danger_penalty += zone['danger_level'] * 10

        return distance + danger_penalty

    def plan_safe_route(self, start, destination):
        """è§„åˆ’èº²é¿è·¯çº¿"""
        routes = []

        # 1. ç›´çº¿è·¯çº¿
        direct_route = {
            'waypoints': [start, destination],
            'cost': self.calculate_route_cost(start, destination)
        }
        routes.append(direct_route)

        # 2. ç»•è¡Œè·¯çº¿ï¼ˆé€šè¿‡ä¸­é—´ç‚¹ï¼‰
        for angle in range(0, 360, 45):  # æ¯45åº¦ä¸€ä¸ªç»•è¡Œç‚¹
            waypoint = self.generate_waypoint(start, destination, angle)
            detour_route = {
                'waypoints': [start, waypoint, destination],
                'cost': (
                    self.calculate_route_cost(start, waypoint) +
                    self.calculate_route_cost(waypoint, destination)
                )
            }
            routes.append(detour_route)

        # 3. é€‰æ‹©ä»£ä»·æœ€å°çš„è·¯çº¿
        best_route = min(routes, key=lambda x: x['cost'])

        return {
            'route': best_route['waypoints'],
            'distance_km': self.calculate_route_distance(best_route['waypoints']),
            'danger_zones_crossed': self.get_crossed_zones(best_route['waypoints']),
            'safety_score': self.calculate_safety_score(best_route)
        }

    def haversine_distance(self, lat1, lon1, lat2, lon2):
        """è®¡ç®—åœ°çƒè¡¨é¢è·ç¦»ï¼ˆå…¬é‡Œï¼‰"""
        from math import radians, sin, cos, asin, sqrt

        lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * asin(sqrt(a))
        return 6371 * c  # åœ°çƒåŠå¾„6371å…¬é‡Œ
```

---

## ğŸ¨ å‰ç«¯å¯è§†åŒ–

### 1. å±é™©åŒºåŸŸæ ‡æ³¨

```javascript
function renderDangerZones(hotspots) {
  hotspots.forEach(hotspot => {
    // ç»˜åˆ¶çº¢è‰²å±é™©åŒºåŸŸåœ†åœˆ
    const dangerCircle = L.circle(
      [hotspot.center.lat, hotspot.center.lon],
      {
        color: '#ff0000',
        fillColor: '#ff0000',
        fillOpacity: 0.2,
        radius: hotspot.radius * 111000,  // è½¬æ¢ä¸ºç±³
        className: 'danger-zone'
      }
    ).addTo(map);

    dangerCircle.bindPopup(`
      <b>âš ï¸ å±é™©åŒºåŸŸ</b><br>
      ${hotspot.name}<br>
      è®¿é—®æ¬¡æ•°: ${hotspot.visit_count}<br>
      å±é™©ç­‰çº§: ${hotspot.danger_level}/10
    `);
  });
}
```

**æ•ˆæœ**:
- çº¢è‰²åŠé€æ˜åœ†åœˆ
- åŠå¾„æ ¹æ®æ´»åŠ¨èŒƒå›´åŠ¨æ€è°ƒæ•´
- ç‚¹å‡»æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯

---

### 2. é¢„æµ‹ä½ç½®æ˜¾ç¤º

```javascript
function showPredictions(predictions) {
  predictions.forEach(pred => {
    // åŠé€æ˜æ ‡è®°è¡¨ç¤ºé¢„æµ‹ä½ç½®
    const predMarker = L.marker([pred.lat, pred.lon], {
      icon: L.divIcon({
        className: 'prediction-marker',
        html: `
          <div style="
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid #ff0000;
            border-radius: 50%;
          ">
            <span style="font-size: 10px;">${pred.time}</span>
          </div>
        `
      })
    }).addTo(map);

    predMarker.bindPopup(`
      <b>é¢„æµ‹ä½ç½®</b><br>
      æ—¶é—´: ${pred.time}<br>
      ç½®ä¿¡åº¦: ${(pred.confidence * 100).toFixed(1)}%
    `);
  });
}
```

---

### 3. å®‰å…¨è·¯çº¿ç»˜åˆ¶

```javascript
function displaySafeRoute(route) {
  // å®‰å…¨è·¯çº¿ï¼ˆç»¿è‰²ï¼‰
  const safeRoute = L.polyline(route.waypoints, {
    color: '#00ff00',
    weight: 4,
    opacity: 0.7,
    dashArray: '10, 5'
  }).addTo(map);

  // æ·»åŠ è·¯çº¿ä¿¡æ¯
  safeRoute.bindPopup(`
    <b>ğŸ›¡ï¸ å®‰å…¨è·¯çº¿</b><br>
    è·ç¦»: ${route.distance_km.toFixed(2)} km<br>
    å®‰å…¨è¯„åˆ†: ${route.safety_score}/100<br>
    ç»è¿‡å±é™©åŒº: ${route.danger_zones_crossed.join(', ') || 'æ— '}
  `);

  // è‡ªåŠ¨é€‚åº”è§†å›¾
  map.fitBounds(safeRoute.getBounds());
}
```

---

### 4. å®æ—¶é‡æ–°è§„åˆ’

```javascript
function monitorAndReplan(myLocation, destination, targetId) {
  setInterval(async () => {
    // è·å–ç›®æ ‡å½“å‰ä½ç½®
    const response = await fetch(`/api/track/target/${targetId}`);
    const targetLocation = await response.json();

    // è®¡ç®—è·ç¦»
    const distance = calculateDistance(myLocation, targetLocation);

    if (distance < 1) {  // è·ç¦»å°äº1å…¬é‡Œ
      // ç´§æ€¥é‡æ–°è§„åˆ’
      const newRoute = await fetch('/api/route/replan', {
        method: 'POST',
        body: JSON.stringify({
          start: myLocation,
          destination: destination,
          target_location: targetLocation
        })
      }).then(r => r.json());

      displaySafeRoute(newRoute);
      showAlert('âš ï¸ ç›®æ ‡æ¥è¿‘ï¼å·²é‡æ–°è§„åˆ’è·¯çº¿');
    }
  }, 10000);  // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
}
```

---

## ğŸ”’ æ³•å¾‹ä¸é“å¾·

### âš ï¸ é‡è¦è­¦å‘Š

**æœªç»æˆæƒè¿½è¸ªä»–äººæ˜¯è¿æ³•çš„ï¼**

**è¿æ³•è¡Œä¸º**:
- âŒ æœªç»åŒæ„å®šä½ä»–äººä½ç½®
- âŒ éæ³•è·å–é€šä¿¡è®°å½•
- âŒ ä¾µçŠ¯ä¸ªäººéšç§
- âŒ è·Ÿè¸ªã€éªšæ‰°ä»–äºº

**æ³•å¾‹åæœ**:
- è¿åã€Šåˆ‘æ³•ã€‹ç¬¬253æ¡ä¹‹ä¸€ï¼šä¾µçŠ¯å…¬æ°‘ä¸ªäººä¿¡æ¯ç½ª
- è¿åã€Šä¸ªäººä¿¡æ¯ä¿æŠ¤æ³•ã€‹
- å¯èƒ½åˆ¤å¤„3-7å¹´æœ‰æœŸå¾’åˆ‘

---

### âœ… åˆæ³•ä½¿ç”¨åœºæ™¯

| åœºæ™¯ | æ˜¯å¦åˆæ³• | å‰ææ¡ä»¶ |
|------|---------|---------|
| **å®¶é•¿ç›‘æŠ¤æœªæˆå¹´å­å¥³** | âœ… åˆæ³• | å­å¥³çŸ¥æƒ…ï¼Œç›‘æŠ¤æƒèŒƒå›´å†… |
| **ä¼ä¸šè¿½è¸ªå…¬å¸è½¦è¾†** | âœ… åˆæ³• | å‘˜å·¥ç­¾ç½²åŒæ„ä¹¦ |
| **ç´§æ€¥æ•‘æ´å®šä½** | âœ… åˆæ³• | ç”Ÿå‘½å®‰å…¨ç´§æ€¥éœ€è¦ |
| **æ‰§æ³•æœºå…³è¿½è¸ª** | âœ… åˆæ³• | æ³•é™¢æ‰¹å‡†ï¼Œä¾¦æŸ¥éœ€è¦ |
| **æœªç»åŒæ„è¿½è¸ªä»–äºº** | âŒ è¿æ³• | æ— ä»»ä½•ä¾‹å¤– |

---

### ğŸ›¡ï¸ éšç§ä¿æŠ¤å»ºè®®

**å¦‚ä½•é˜²æ­¢è¢«è¿½è¸ª**:

1. **æ£€æŸ¥æ‰‹æœº**
   - å®šæœŸæ£€æŸ¥æ˜¯å¦å®‰è£…è¿½è¸ªè½¯ä»¶
   - æŸ¥çœ‹åå°è¿è¡Œçš„åº”ç”¨
   - ç›‘æ§æµé‡å¼‚å¸¸

2. **å…³é—­å®šä½æœåŠ¡**
   - ä¸ä½¿ç”¨æ—¶å…³é—­GPS
   - é™åˆ¶åº”ç”¨å®šä½æƒé™
   - ä½¿ç”¨"ä»…ä½¿ç”¨æ—¶å…è®¸"

3. **ç¤¾äº¤åª’ä½“**
   - ä¸è¦å…¬å¼€ç­¾åˆ°ä½ç½®
   - é™åˆ¶æœ‹å‹åœˆå¯è§èŒƒå›´
   - å…³é—­"é™„è¿‘çš„äºº"

4. **æŠ€æœ¯é˜²æŠ¤**
   - ä½¿ç”¨VPNéšè—IP
   - å®šæœŸæ›´æ¢ç”µè¯å·ç 
   - ä½¿ç”¨éšç§ä¿æŠ¤å·¥å…·

---

## ğŸ’¡ å®é™…åº”ç”¨ï¼ˆåˆæ³•åœºæ™¯ï¼‰

### åœºæ™¯1: å®¶é•¿ç›‘æŠ¤

**éœ€æ±‚**: å®¶é•¿ç›‘æ§æœªæˆå¹´å­å¥³ä½ç½®ï¼Œç¡®ä¿å®‰å…¨

**å®ç°**:
- å­å¥³æ‰‹æœºå®‰è£…å®šä½Appï¼ˆç»åŒæ„ï¼‰
- å®¶é•¿ç«¯å®æ—¶æŸ¥çœ‹ä½ç½®
- è®¾ç½®å­¦æ ¡ã€å®¶åº­å®‰å…¨åŒºåŸŸ
- ç¦»å¼€å®‰å…¨åŒºåŸŸå‘Šè­¦

**åˆæ³•æ€§**: âœ… ç›‘æŠ¤æƒèŒƒå›´å†…ï¼Œå­å¥³çŸ¥æƒ…

---

### åœºæ™¯2: ä¼ä¸šè½¦é˜Ÿç®¡ç†

**éœ€æ±‚**: ç‰©æµå…¬å¸è¿½è¸ªè¿è¾“è½¦è¾†

**å®ç°**:
- è½¦è¾†å®‰è£…GPSè®¾å¤‡
- å¸æœºç­¾ç½²åŒæ„ä¹¦
- è°ƒåº¦ä¸­å¿ƒç›‘æ§ä½ç½®
- ä¼˜åŒ–é…é€è·¯çº¿

**åˆæ³•æ€§**: âœ… åŠ³åŠ¨åˆåŒçº¦å®šï¼Œå‘˜å·¥åŒæ„

---

### åœºæ™¯3: ç´§æ€¥æ•‘æ´

**éœ€æ±‚**: ç™»å±±è€…é‡é™©ï¼Œæ•‘æ´é˜Ÿå®šä½

**å®ç°**:
- ç™»å±±è€…æºå¸¦GPSè¿½è¸ªå™¨
- é‡é™©æ—¶æ¿€æ´»æ±‚æ•‘ä¿¡å·
- æ•‘æ´é˜Ÿè·å–ä½ç½®
- è§„åˆ’æœ€å¿«æ•‘æ´è·¯çº¿

**åˆæ³•æ€§**: âœ… ç”Ÿå‘½å®‰å…¨ï¼Œå½“äº‹äººæ±‚æ•‘

---

## ğŸ“ˆ æŠ€æœ¯éš¾ç‚¹ä¸è§£å†³æ–¹æ¡ˆ

### éš¾ç‚¹1: è·å–ç›®æ ‡ä½ç½®æ•°æ®

**é—®é¢˜**: è¿è¥å•†å®šä½APIéœ€è¦é«˜æƒé™

**è§£å†³æ–¹æ¡ˆ**:
- æ–¹æ¡ˆA: ä½¿ç”¨å…¬å¼€ä¿¡æ¯ï¼ˆå·ç å½’å±åœ°ã€ç¤¾äº¤åª’ä½“ç­¾åˆ°ï¼‰
- æ–¹æ¡ˆB: å®¶åº­å…±äº«ä½ç½®åŠŸèƒ½ï¼ˆåˆæ³•æˆæƒï¼‰
- æ–¹æ¡ˆC: ä¼ä¸šçº§å®šä½æœåŠ¡ï¼ˆå•†ä¸šæˆæƒï¼‰

---

### éš¾ç‚¹2: å†å²è½¨è¿¹æ•°æ®ä¸è¶³

**é—®é¢˜**: 30å¤©æ•°æ®ä¸è¶³ä»¥åˆ†ææ¨¡å¼

**è§£å†³æ–¹æ¡ˆ**:
- å»¶é•¿æ”¶é›†æ—¶é—´ï¼ˆ90å¤©ï¼‰
- é™ä½èšç±»é˜ˆå€¼ï¼ˆmin_samples=3ï¼‰
- ç»“åˆå…¬å¼€ä¿¡æ¯è¡¥å……ï¼ˆç¤¾äº¤åª’ä½“ã€è¯„è®ºï¼‰

---

### éš¾ç‚¹3: å®æ—¶ä½ç½®æ›´æ–°é¢‘ç‡

**é—®é¢˜**: æ¯ç§’æ›´æ–°ä¼šæ¶ˆè€—å¤§é‡æµé‡

**è§£å†³æ–¹æ¡ˆ**:
- ç§»åŠ¨æ—¶é«˜é¢‘ï¼ˆ5ç§’ï¼‰
- é™æ­¢æ—¶ä½é¢‘ï¼ˆ30ç§’ï¼‰
- ä½ç§»è¶…è¿‡50ç±³æ‰æ›´æ–°

```python
def should_update(old_pos, new_pos):
    distance = calculate_distance(old_pos, new_pos)
    return distance > 0.05  # 50ç±³
```

---

### éš¾ç‚¹4: è·¯çº¿è§„åˆ’æ€§èƒ½

**é—®é¢˜**: A*ç®—æ³•åœ¨å¤§è§„æ¨¡è·¯ç½‘ä¸­è®¡ç®—æ…¢

**è§£å†³æ–¹æ¡ˆ**:
- ä½¿ç”¨ç°æˆè·¯ç”±æœåŠ¡ï¼ˆOSRMã€Google Directionsï¼‰
- ç¼“å­˜å¸¸ç”¨è·¯çº¿
- é¢„è®¡ç®—å±é™©åŒºåŸŸ

```python
@lru_cache(maxsize=1000)
def get_route(start_lat, start_lon, end_lat, end_lon):
    # ç¼“å­˜è·¯çº¿
    pass
```

---

## ğŸš€ éƒ¨ç½²æ­¥éª¤

### 1. å®‰è£…ä¾èµ–

```bash
pip install flask requests numpy scikit-learn
```

### 2. ä¸‹è½½GeoIPæ•°æ®åº“

```bash
wget https://github.com/P3TERX/GeoLite.mmdb/raw/download/GeoLite2-City.mmdb \
  -O data/GeoLite2-City.mmdb
```

### 3. é…ç½®APIå¯†é’¥

**ç¼–è¾‘ `.env` æ–‡ä»¶**:

```bash
# è¿è¥å•†å®šä½APIï¼ˆéœ€ç”³è¯·ï¼‰
CARRIER_API_KEY=your_api_key_here

# åœ°å›¾è·¯ç”±æœåŠ¡
OSRM_SERVER=http://router.project-osrm.org

# é€†åœ°ç†ç¼–ç 
NOMINATIM_EMAIL=your@email.com
```

### 4. å¯åŠ¨æœåŠ¡

```bash
python fairy-desk/avoidance_system.py
```

### 5. æµ‹è¯•

```python
from avoidance_system import PersonAvoidanceSystem

system = PersonAvoidanceSystem()

# 1. è¿½è¸ªç›®æ ‡ï¼ˆæ¨¡æ‹Ÿæ•°æ®ï¼‰
target_phone = '13800138000'
hotspots = system.track_target(target_phone, duration_days=30)

# 2. è§„åˆ’èº²é¿è·¯çº¿
my_location = {'lat': 39.9042, 'lon': 116.4074}
destination = {'lat': 39.9163, 'lon': 116.3972}

result = system.avoid_and_navigate(my_location, destination, target_phone)
print(f"å®‰å…¨è·¯çº¿: {result['safe_route']}")
```

---

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | æ•°å€¼ | è¯´æ˜ |
|------|------|------|
| **å®šä½ç²¾åº¦** | 50-1000ç±³ | åŸºç«™å®šä½ |
| **å®šä½ç²¾åº¦** | 5-10ç±³ | GPSå®šä½ |
| **èšç±»æ—¶é—´** | <1ç§’ | 1000ä¸ªä½ç½®ç‚¹ |
| **é¢„æµ‹å‡†ç¡®ç‡** | 70-85% | 30å¤©å†å²æ•°æ® |
| **è·¯çº¿è§„åˆ’** | <2ç§’ | å•æ¬¡è§„åˆ’ |
| **æ•°æ®é‡** | 30å¤©Ã—24å°æ—¶ | 720ä¸ªä½ç½®ç‚¹ |

---

## ğŸ“š å‚è€ƒèµ„æº

### ç®—æ³•è®ºæ–‡

- **DBSCAN**: "A Density-Based Algorithm for Discovering Clusters" (1996)
- **Trilateration**: "GPS Position Location Principles" (2011)
- **A* Pathfinding**: "A Formal Basis for the Heuristic Determination of Minimum Cost Paths" (1968)

### å¼€æºé¡¹ç›®

- **OwnTracks**: å¼€æºä½ç½®è¿½è¸ªåº”ç”¨
- **Traccar**: GPSè¿½è¸ªå¹³å°
- **OSRM**: å¼€æºè·¯ç”±å¼•æ“

---

## ğŸ“ TODOæ¸…å•

- [ ] å®ç°ç”µè¯å·ç å®šä½APIé›†æˆ
- [ ] å¼€å‘æ´»åŠ¨æ¨¡å¼åˆ†æå™¨
- [ ] å®ç°DBSCANèšç±»ç®—æ³•
- [ ] å¼€å‘èº²é¿è·¯çº¿è§„åˆ’å™¨
- [ ] åˆ›å»ºå‰ç«¯å¯è§†åŒ–ç•Œé¢
- [ ] é›†æˆåˆ°FAIRY-DESK
- [ ] æ·»åŠ å®æ—¶é‡æ–°è§„åˆ’
- [ ] ç¼–å†™æ³•å¾‹åˆè§„æ–‡æ¡£
- [ ] æ€§èƒ½æµ‹è¯•ä¸ä¼˜åŒ–
- [ ] ç”¨æˆ·éšç§ä¿æŠ¤åŠŸèƒ½

---

## âš–ï¸ åˆè§„å£°æ˜

**æœ¬ç³»ç»Ÿä»…ä¾›ä»¥ä¸‹åˆæ³•ç”¨é€”**:

1. âœ… å®¶é•¿ç›‘æŠ¤æœªæˆå¹´å­å¥³ï¼ˆéœ€å­å¥³çŸ¥æƒ…ï¼‰
2. âœ… ä¼ä¸šç®¡ç†å…¬å¸èµ„äº§ï¼ˆéœ€å‘˜å·¥åŒæ„ï¼‰
3. âœ… ç´§æ€¥æ•‘æ´å®šä½ï¼ˆç”Ÿå‘½å®‰å…¨éœ€è¦ï¼‰
4. âœ… æ‰§æ³•æœºå…³ä¾æ³•ä½¿ç”¨ï¼ˆéœ€æ³•å¾‹æˆæƒï¼‰
5. âœ… å­¦æœ¯ç ”ç©¶å’ŒæŠ€æœ¯æ¼”ç¤ºï¼ˆè™šæ‹Ÿæ•°æ®ï¼‰

**ç¦æ­¢ç”¨é€”**:

1. âŒ æœªç»åŒæ„è¿½è¸ªä»–äºº
2. âŒ è·Ÿè¸ªã€éªšæ‰°ã€å¨èƒä»–äºº
3. âŒ ä¾µçŠ¯ä¸ªäººéšç§
4. âŒ å•†ä¸šéæ³•ç‰Ÿåˆ©
5. âŒ å…¶ä»–è¿æ³•çŠ¯ç½ªæ´»åŠ¨

**ä½¿ç”¨æœ¬ç³»ç»Ÿå³è¡¨ç¤ºæ‚¨åŒæ„éµå®ˆæ‰€æœ‰é€‚ç”¨çš„æ³•å¾‹æ³•è§„ã€‚å¼€å‘è€…ä¸å¯¹ä»»ä½•éæ³•ä½¿ç”¨è¡Œä¸ºè´Ÿè´£ã€‚**

---

## ğŸ† é¡¹ç›®æ€»ç»“

### æŠ€æœ¯å¯è¡Œæ€§

**ã€Šé£å“¥ä¸å°ä½›ã€‹ä¸­çš„åŠŸèƒ½åœ¨ç°å®ä¸­å®Œå…¨å¯è¡Œ**ï¼š

| åŠŸèƒ½ | åŠ¨ç”»ç‰‡ | ç°å®æŠ€æœ¯ | å¯è¡Œæ€§ |
|------|--------|---------|--------|
| ç”µè¯å·ç å®šä½ | âœ… | åŸºç«™/GPSå®šä½ | âœ… å¯è¡Œ |
| å¸¸å»åœ°ç‚¹åˆ†æ | âœ… | DBSCANèšç±» | âœ… å¯è¡Œ |
| æ—¶é—´æ¨¡å¼é¢„æµ‹ | âœ… | ç»Ÿè®¡å­¦ä¹  | âœ… å¯è¡Œ |
| èº²é¿è·¯çº¿è§„åˆ’ | âœ… | A*+æƒ©ç½šå‡½æ•° | âœ… å¯è¡Œ |
| é¢„æµ‹å‡†ç¡®ç‡ | æœªçŸ¥ | 70-85% | âœ… å®ç”¨ |

### å…³é”®æŠ€æœ¯

- **DBSCANèšç±»**: è¯†åˆ«å¸¸å»åœ°ç‚¹
- **ä¸‰è§’å®šä½**: åŸºç«™ä¿¡å·å®šä½
- **A*ç®—æ³•**: æœ€ä¼˜è·¯å¾„è§„åˆ’
- **Haversineå…¬å¼**: åœ°çƒè¡¨é¢è·ç¦»

### é‡è¦æé†’

âš ï¸ **æŠ€æœ¯èƒ½åŠ›ä¸ç­‰äºä½¿ç”¨æƒåˆ©**

å³ä½¿æŠ€æœ¯ä¸Šå®Œå…¨å¯è¡Œï¼Œä¹Ÿå¿…é¡»åœ¨**åˆæ³•åˆè§„**çš„å‰æä¸‹ä½¿ç”¨ï¼

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2026-02-03
**çŠ¶æ€**: ğŸ“‹ è§„åˆ’å®Œæˆï¼Œè¯·ç¡®ä¿åˆæ³•ä½¿ç”¨
